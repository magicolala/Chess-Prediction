"""Compatibility CLI for batch PGN analysis using the local pipeline."""

from __future__ import annotations

import argparse
import csv
import io
import os
from typing import Callable, Dict, Iterable, Optional

import chess
import chess.pgn

from oracle.pipeline.analyze import analyze as default_analyze

DEFAULT_ELO = 1500
DEFAULT_TIME_CONTROL = "classical"


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Batch analyze PGN games")
    parser.add_argument("--pgn", required=False, help="Path to PGN file")
    parser.add_argument("--output", required=False, help="Path to CSV output")
    parser.add_argument("--depth", type=int, default=3)
    parser.add_argument("--prob-threshold", type=float, default=0.0)
    parser.add_argument("--top-k", type=int, default=None)
    return parser.parse_args()


def _iterate_games(path: str) -> Iterable[str]:
    with open(path, "r", encoding="utf-8") as handle:
        while True:
            game = chess.pgn.read_game(handle)
            if game is None:
                break
            exporter = chess.pgn.StringExporter(
                headers=True, variations=False, comments=False
            )
            game.accept(exporter)
            yield str(exporter)


def _normalize_time_control(value: str) -> str:
    value = value.lower()
    if value in {"bullet", "blitz", "rapid", "classical"}:
        return value
    base = value.split("+")[0]
    try:
        if ":" in base:
            minutes, seconds = base.split(":")
            total_seconds = int(minutes) * 60 + int(seconds)
        else:
            total_seconds = int(base)
    except ValueError:
        return DEFAULT_TIME_CONTROL
    if total_seconds <= 120:
        return "bullet"
    if total_seconds <= 300:
        return "blitz"
    if total_seconds <= 900:
        return "rapid"
    return "classical"


def _derive_context(pgn: str) -> Dict[str, object]:
    game = chess.pgn.read_game(io.StringIO(pgn))
    headers = game.headers if game else {}

    def _parse_elo(value: Optional[str]) -> int:
        if not value:
            return DEFAULT_ELO
        try:
            return int(value)
        except (ValueError, TypeError):
            return DEFAULT_ELO

    elo_env = os.getenv("ORACLE_ELO")
    time_env = os.getenv("ORACLE_TIME_CONTROL")

    elo = _parse_elo(headers.get("WhiteElo") or headers.get("BlackElo") or elo_env)
    time_control = _normalize_time_control(
        headers.get("TimeControl") or time_env or DEFAULT_TIME_CONTROL
    )
    return {"elo": elo, "time_control": time_control}


def main(
    *,
    pgn_path: Optional[str] = None,
    output_path: Optional[str] = None,
    analyze_fn: Callable[..., Dict[str, object]] = default_analyze,
    depth: int = 3,
    prob_threshold: float = 0.0,
    top_k: Optional[int] = None,
) -> None:
    if pgn_path is None or output_path is None:
        args = _parse_args()
        pgn_path = pgn_path or args.pgn
        output_path = output_path or args.output
        depth = args.depth
        prob_threshold = args.prob_threshold
        top_k = args.top_k

    if not pgn_path or not output_path:
        raise ValueError("Both PGN and output paths must be provided")

    rows = []
    for game_index, game_pgn in enumerate(_iterate_games(pgn_path), start=1):
        context = _derive_context(game_pgn)
        result = analyze_fn(
            pgn=game_pgn,
            ctx=context,
            depth=depth,
            prob_threshold=prob_threshold,
            top_k=top_k,
        )
        for move_index, move in enumerate(result.get("moves", []), start=1):
            rows.append(
                {
                    "game_index": game_index,
                    "move_index": move_index,
                    "san": move.get("san", ""),
                    "prior_pct": move.get("prior_pct", 0.0),
                    "adjusted_pct": move.get("adjusted_pct", 0.0),
                    "sf_eval_cp": move.get("sf_eval_cp", ""),
                    "quality": move.get("quality", ""),
                }
            )

    with open(output_path, "w", newline="", encoding="utf-8") as handle:
        writer = csv.DictWriter(
            handle,
            fieldnames=[
                "game_index",
                "move_index",
                "san",
                "prior_pct",
                "adjusted_pct",
                "sf_eval_cp",
                "quality",
            ],
        )
        writer.writeheader()
        for row in rows:
            writer.writerow(row)


if __name__ == "__main__":
    main()
